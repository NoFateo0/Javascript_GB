<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>lesson 8</title>
  </head>
  <body>
    <script>
      // Задание 1
      // Замыкания позволяют связать данные из лексического окружения с функцией, которая эти данные использует.
      // Удобно применять там, где какие-то данные нужно связать с несколькими методами, например. Часто используется, когда мы применяем addEventListener.

      // Задание 2
      if (!("a" in window)) {
        var a = 1;
      }
      alert(a);
      // Здесь сначала объявлется переменная a, которая становится свойством объекта windows, поэтому проверка
      // !("a" in window) даст нам false и мы не зайдем в if. В итоге alert(a) даст нам undefined, потому что переменная a объявлена, но значение не присвоено.

      var b = function a(x) {
        x && a(--x);
      };
      alert(a);
      // Тут нам выдаст ошибку, потому что переменная a не объявлена.

      function a(x) {
        return x * 2;
      }
      var a;
      alert(a);
      // Тут нам выдаст просто тело функции а, хотя дальше по коду объявляется переменная ф. Все потому, что объявление функции имеет приоритет перед объявлением переменной.

      function b(x, y, a) {
        arguments[2] = 10;
        alert(a);
      }
      b(1, 2, 3);
      // Функция вернет второй аргумент, т.е. а == 10. Все аргументы функции хранятся в псевдомассиве arguments, даляя второму аргументу присваивается значение 10 и оно же и выводится в alert.

      ("use strict");
      function a() {
        alert(this);
      }
      a.call(null);
      //Ключевое слово this относится к объекту, который вызывает функцию, в данном случае объект явно не указан, поэтому функция вернет глабальный объект window.
    </script>
  </body>
</html>
